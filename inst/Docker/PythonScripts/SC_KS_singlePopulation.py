import scipy.io
import matplotlib.pyplot as plt
import numpy as np
import os
import glob
import pandas as pd
import time
import sys

sys.path.append('PythonScripts')
import MyFunctions2 as F 

"""
This script compares the single cell distributions for each feature with the a
reference distribution. The reference distribution is generated by aggregating 
all the distribution of single control cells for aech feature. The comparison 
is performed by KS statistic.


input: matrix of rab clusters. rows: rab clusters. columns: 
 cell label/Rab features/cell features

output: matrix of single cells. Rows: single cells. Columns: Rab features


"""


# Record the start time
start_time = time.perf_counter()

""" REFERENCE DISTRIBUTION FILE LOADING """

# Specify the folder containing the .mat control file
CTRL_path = sys.argv[1] # 'C:/Users/E14Ge/Desktop/Rab clusters data features2/screening/control'

# Find .mat control filee in the folder
#CTRLmat_files = glob.glob(os.path.join(CTRL_path, '*.mat'))

# Load the .mat control file
# ClusterA: Rab5
# ClusterB: Rab11
#CTRLmat_data = scipy.io.loadmat(CTRLmat_files[0])
CTRLmat_data = scipy.io.loadmat(CTRL_path)
ctrl = CTRLmat_data['ClustersB']


""" FILES LOADING OF THE CONDITION TO BE COMPARED """
 
# Specify the folder containing the .mat file to be compared to reference distribution
# ClusterA: Rab5
# ClusterB: Rab11
COMP_path = sys.argv[2] #'C:/Users/E14Ge/Desktop/Rab clusters data features2/screening/treated'

# Find .mat control files in the folder
# COMPmat_files = glob.glob(os.path.join(COMP_path, '*.mat'))

# Load the .mat control file
# COMPmat_data = scipy.io.loadmat(COMPmat_files[0])
COMPmat_data = scipy.io.loadmat(COMP_path)
comp = COMPmat_data['ClustersB']


""" DATA CLEANING """

print("Data cleaning")

# clean data from eventual nan and inf
# I get the input matrices of Rab clusters clean and in a numpy array form
ctrl = F.cleaning(ctrl)
comp = F.cleaning(comp)


""" KS MATRIX GENERATION """

Mcomp = int(max(comp[:,0])) # max label of treated cells


# Preprocess data into dictionary: label indicate cells. For each label i 
# a matrix where rows are Rab clusters and columns features is generated. This 
#allow to me to have already stored all the single cell distribution, improving 
# script running time
comp_groups = {label: comp[comp[:, 0] == label, :] for label in np.unique(comp[:, 0])}


print('\n')
print("KS variability estimation")
print('\n')


KScontrol = pd.DataFrame()

# user can chose the feature
for n in range(1,13):# loop on the feature of interest (only Rab features)
    
    print('\n')
    print(n)
    
    # store KS values per single cell of each feature n
    KSv = []
    
    for i in range(1,Mcomp+1):# loop on the single cell to be compared with the reference distribution
        
        # Calculate percentage of loop procedure
        percent = (i / Mcomp) * 100
        
        # Print percentage dynamically
        print(f"\rProgress: {percent:.2f}%", end="")
        
        # Generate the single cell distribution to be compared for feature n 
        compN = comp_groups[i][:, n]
        
        # Generate the reference distribution for feature n
        Ref = ctrl[:, n]
        
        # perform KS statistic by adding the sign
        # N.B. : since the KS is signed the reference distribution must be the 
        # first term in the fucntion
        KS = F.two_sample_signed_ks_statistic(Ref,compN)
        KSv.append(KS[1])
        
    
    # store KS values of each single cell for feature n
    KScontrol[n] = KSv
    

# convert from dataframe to numpy
KScontrol = KScontrol.to_numpy()

""" DATAFRAME CREATION """

# Create new dataframe where the colums contain the name of the feature measured

print("Dataframe creation")

# Load the column names from the Excel file
# The feature names are listed in an excel file
excel_file = './Data/featuresPython2.xlsx'
column_names_df = pd.read_excel(excel_file, sheet_name='Sheet1', header=None)

# Extract the column names from the first row
column_names = column_names_df.iloc[0].tolist()

# Ensure the length of column_names matches the number of columns in your data matrix
# 12
num_columns = 12
if len(column_names) != num_columns:
    raise ValueError("Number of column names in Excel file does not match the number of columns in the data matrix")

# Convert the NumPy array to a Pandas DataFrame with the loaded column names
df = pd.DataFrame(KScontrol, columns=column_names)


# dataframe saving
df.to_excel('./Data/KS_singlePopulation.xlsx',index=False) 


# Record the end time
end_time = time.perf_counter()

# Calculate the elapsed time
elapsed_time = end_time - start_time

# Print the elapsed time
print('\n')
print(f"Execution time: {elapsed_time:.6f} seconds") 
